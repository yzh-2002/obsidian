题目：
![image.png](https://raw.githubusercontent.com/yzh-2002/img-hosting/main/notes/202410181953392.png)

---
[参考链接](https://blog.csdn.net/sinat_37853238/article/details/127078940)
## 内核编程

内核开发时，通过`uname -r`查看当前主机的内核版本（内核编程与内核版本紧密相连），然后在`usr/src`查看是否包含对应内核版本的代码。不存在需要下载，之后便可以开发了。

`VSCode`编写代码时可能会提示各种错误（找不到头文件等等），贴一份`c_cpp_properties.json`：
```json
{ 
	"configurations": [ 
		{ 
		"name": "Linux", 
		"includePath": [ 
			"${workspaceFolder}/**", 
			"/usr/src/linux-headers-6.5.0-28-generic/", 
			"/usr/src/linux-headers-6.5.0-28-generic/include/", 
			"/usr/src/linux-headers-6.5.0-28-generic/arch/x86/include/",   "/usr/src/linux-headers-6.5.0-28-generic/arch/x86/include/generated/",     "/usr/src/linux-hwe-6.5-headers-6.5.0-28/arch/**/include/", 
			"/usr/src/linux-hwe-6.5-headers-6.5.0-28/include/" 
		], 
		// 参考链接：https://stackoverflow.com/questions/71735229
		"defines": ["__KERNEL__","MODULE"], 
		"compilerPath": "/usr/bin/gcc", 
		"cStandard": "c17", 
		"cppStandard": "gnu++17", 
		"intelliSenseMode": "linux-gcc-x64" 
		} 
	], 
	"version": 4 
}
```

内核编程：`Hello World`
```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

//模块许可证声明,必须
MODULE_LICENSE("GPL");

//模块加载函数,必须
static int hello_init(void){
    printk(KERN_ALERT "Hello Kernel!");
    return 0;
}
// 另一种写法，较之上面写法省内存，原因其初始化之后释放该函数及其所占内存
// static int __init hello_init(void){}

//模块卸载函数,必须
static void hello_exit(void){
	printk(KERN_ALERT "Goodbye Kernel/n");
}
// static void __exit hello_exit(void){}

//模块的注册
module_init(hello_init);
module_exit(hello_exit);
```

内核编程实际上是对于Linux可加载**内核模块**的编写，内核模块是具有独立功能的程序，可单独编译，但不能单独运行，其运行必须被链接到内核作为内核的一部分在内核空间中运行。

如何将编写的内核模块加载到内核呢？
1. 静态编译进内核，内核启动时自动加载
2. 使用`insmod`命令将模块动态加载到正在运行的内核，不需要时用`rmmod`命令将模块卸载

再回到上面的`Hello World`代码，不同于应用编程中以`main`函数作为入口，模块采用`module_init`作为模块入口，`module_exit`指定了模块退出时的出口函数。

### Makefile
> 可以在终端中使用`gcc`编译代码生成可执行文件，但内核编写时，由于需要显式指定内核版本等信息，通过`Makefile`要比`gcc`方便很多

`gcc`是编译器，`make`是一个命令工具，用于解释`Makefile`中的指令（从而执行一组`gcc/g++`为主的shell命令序列）。

内核编程的`Makefile`示例：
```Makefile
# -m表示其为一个模块 .o目标文件（机器码，与所需库文件链接在一起即可构成可执行文件）
obj-m += hello.o
CURRENT_PATH:=$(shell pwd)
LINUX_KERNEL:=$(shell uname -r)
LINUX_KERNEL_PATH:=/usr/src/linux-headers-$(LINUX_KERNEL)

all:
	# -C 指定读取Makefile文件的目录
	# M 指定模块源代码的位置
	# modules 表示构建目标是内核模块
    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules
clean:
    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean
```

经编译之后生成如下文件：
1. `hello.o`：模块的目标文件，生成`hello.ko`文件的基础
2. `hello.ko`：**最终生成的内核模块代码，可被内核加载和执行**
	1. `insmod xxx.ko`：将模块加载入内核
	2. `rmmod xxx.ko`：将模块从内核中卸载
3. `hello.mod`：
4. `hello.mod.c`
5. `hello.mode.o`
6. `Modules.symvers`
7. `modules.order`

常见问题：
1. `Key was rejected by service`：
	1. `Linux内核`从3.7开始加入了模块签名检查机制，加载模块时内核会检查模块的签名，如果签名不存在或签名内容不一致，会强制退出模块的加载。
	2. 在`/usr/src/linux-$(uname -r)`下执行`make menuconfig`可进入内核配置项，目前已经无法关闭内核模块签名校验的配置项
	3. 签名方法：[参考链接](https://ubuntu.com/blog/how-to-sign-things-for-secure-boot)

## 设计思路
题目要求在IP模块和以太网接口之间串接一个虚拟的`vni0`接口，但是笔记本只有无线网口，没有以太网口，暂时以无线网口实现（应该区别不大，毕竟只是接收端...）

当在linux主机通过`ping`命令向另一台linux主机发送`ICMP`数据包时：
1. 用户空间（**应用层**）：`ping`网络应用程序生成数据，其会使用系统调用将数据传递给内核
	1. `socket()`：应用程序创建一个套接字，指定使用协议（`TCP/UDP`）
	2. `send()/sendto()`：应用程序通过这些调用将数据发送到**内核的网络协议栈**
2. 内核空间（网络协议栈）
	1. **传输层**（`TCP/UDP`）
	2. **网络层**（`IP`）
	3. **链路层**：
linux主机接收到另一台linux主机发送的`ICMP`数据包时：
1. 

### 网络协议栈关键结构
> [Linux 网络协议栈](https://github.com/0voice/linux_kernel_wiki/tree/main/%E6%96%87%E7%AB%A0/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88)
1. `sk_buff`：网络数据包结构，网络协议栈各层均使用该结构存储协议头，用户数据....
2. `net_device`：抽象网络设备，



### Netlink
> Netlink Socket 是用于实现用户进程与内核进程通信的一种特殊的进程间通信方式，也是网络应用程序与内核通信的最常用的接口。

用户态应用使用标准的`Socket API`便可以使用`netlink`提供的强大功能，内核态需要使用专门的`API`来使用`netlink`

### NetFilter 
`netfilter`运行在内核中，是`linux`内置的一种防火墙机制，其如何对网络数据包进行干预呢？**在网络协议栈中预留钩子（`hooks`），这些hook允许内核模块注册回调函数**。

整个网络协议栈如下图所示：
![image.png](https://raw.githubusercontent.com/yzh-2002/img-hosting/main/notes/202410241500621.png)

---
1. `Driver`是网卡驱动程序，网络链路层**靠近硬件一侧**的接口
2. `Device`代表网络设备，不是物理上的设备，而是一个抽象，网络链路层**靠近软件一侧**的接口

在上面网络协议的基础上，`netfliter`是如何运作的可见下图：
![image.png](https://raw.githubusercontent.com/yzh-2002/img-hosting/main/notes/202410241500066.png)

---
1. `prerouting hook`：
2. `forward hook`：经路由后，发现数据包不是发往本机的，本机仅起到路由作用时触发
3. `input hook`：经路由后，发现数据包是发往本机时触发，**可用于加工发往本机的数据包**
4. `output hook`：用于加工本地进程输出的数据包
5. `postrouting hook`：

如何在`netfilter`提供的hook中注册函数呢？

首先，`netfilter`框架为多种协议提供了一套hooks，用`struct list_head nf_hooks[NPROTO][NF_MAX_HOOKS]`二维数组结构存储，一维为协议族，二维为hook点，有五个hook点（与上面的hook对应，名称略有区别）：
1. `NF_IP_PRE_ROUTING`：
2. `NF_IP_LOCAL_IN`：
3. `NF_IP_FORWARD`：
4. `NF_IP_POST_ROUTING`：
5. `NF_IP_LOCAL_OUT`：

hook函数的编写规范如下（**五个参数，一个返回值**）：
```c
unsigned int my_custom_hook(
	unsigned int hooknum,
	struct sk_buff* skb,
	const struct net_device* in,
	const struct net_device* out,
	int (*okfn)(struct sk_buff *) //函数指针，
){
	// TODO
	return NF_ACCEPT;
}
```

每个注册的`hook`函数经过处理后返回值均为下列之一，告知`netfilter`核心代码处理结果，以便对报文采取相应的动作：
1. `NF_ACCEPT`：继续正常的报文处理
2. `NF_DROP`：丢弃报文
3. `NF_STOLEN`：告诉`netfilter`忘掉该数据包，hook函数获取该数据包的所有权，由hook函数控制数据包的生命周期
4. `NF_QUEUE`：报文入队，通常交由用户程序处理
5. `NF_REPEAT`：再次调用该hook函数，谨慎使用，避免死循环

写完`hook`函数，就可以调用`nf_register_hook()`向`netfilter`进行注册挂接，但在调用其之前，需要填写一个`hook options`结构：
```c
struct nf_hook_ops {
	struct list_head list; //由内核管理
	// 用户只需填写下面内容即可
	nf_hookfn *hook; //
	struct_module *owner;
	void *priv;
	u_int8_t pf; //协议族，例如：PF_INET,PF_ARP...
	unsigned int hooknum; //上面提到的五个hook点，需要注意：上述五个宏定义在/usr/include/.../netfilter_ipv4.h 内核空间无法使用，所以需要自己定义
	int priority; //优先级
}
```

### libpcap
> [Libpcap 学习笔记](https://shaocheng.li/posts/2018/04/23/)

## 参考链接

1. [Linux Netfilter Hook技术](https://onestraw.github.io/linux/netfilter-hook/)
2. ...