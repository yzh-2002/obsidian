## 动态规划

1. 将问题拆解为子问题，利用子问题的解构建原问题的解
2. 定义一个状态表示子问题的解
3. 确定状态转移方程：上层问题的解如何由子问题的解推导出来
4. 初始化
5. ...

### 数位dp



## 快速排序

每次递归的过程描述：
1. 每次递归均将pivot右侧元素划分为两区域，第一个区域元素小于pivot，第二个大于
2. 一次遍历，遇到大的元素继续移动，遇到小的元素，需要将其放到第一个区域
	1. 故第一个区域的末尾指针division+1（用于容纳要加入的小元素）
	2. 交换division和i的元素即可
3. 最后需要将pivot元素与division元素互换，完成划分
4. 递归时，最终确定的中间元素下标为division

该算法较之先前学习的快排好理解点
```python
def quick_sort(arr, left, right):  
    # 递归结束条件  
    if right <= left:  
        return  
    pivot = left  
    division = left   
    for i in range(left + 1, right + 1):  
        if arr[i] <= arr[pivot]:  
            division += 1  
            if division != i:  # 也可以省略  
                arr[division], arr[i] = arr[i], arr[division]  
    arr[division], arr[left] = arr[left], arr[division]  
    quick_sort(arr, left, division - 1)  
    quick_sort(arr, division + 1, right)  
    return arr
```

快排优化：
1. 排序数组越随机，算法运行效率越好
2. 对于顺序（逆序）数组，快排的时间复杂度是O(n^2)，解决办法：
	1. **pivot随机选择**，`randomIndex =random.randint(left,right)`
	2. 将其与left的值交换，这样剩余代码无需改动，`arr[randomIndex],arr[left]=arr[left],arr[randomIndex]`
3. 特殊情况：如果数组中存在多种相等的元素，那么随机选择也无法解决效率慢的问题
	1. 双路快排：与pivot相等的元素平均的分到数组两侧
	2. 三路快排：与pivot相等的元素放到中间区域

双路快排优化代码：
```python
def quick_sort(arr, left, right):  
    if right <= left:  
        return  
    # randomIndex = random.randint(left, right)  
    # print(left,right,randomIndex)    # arr[randomIndex], arr[left] = arr[left], arr[randomIndex]    
    pivot = arr[left]  
    small = left + 1  
    large = right  
    while True:  
        # small指针先移动，寻找到大于等于pivot的停下  
        while small <= right and arr[small] < pivot:  
            small += 1  
        # large指针再移动，寻找小于等于pivot的停下（两个循环均要包含等于，这样才能将等于pivot的元素均匀分布在两侧）  
        while large >= left and arr[large] > pivot:  
            large -= 1  
        if small > large:  
            break  
        # 交换small和large对应元素位置  
        arr[small], arr[large] = arr[large], arr[small]  
        small += 1  
        large -= 1  
    arr[large], arr[left] = arr[left], arr[large]  
    quick_sort(arr, left, large - 1)  
    quick_sort(arr, large + 1, right)  
    return arr
```

三路快排：
```python
if right <= left:  
    return  
pivot = arr[left]  
small = left  
large = right  
i = left + 1  
# 此处一定要弄清楚  
# [left+1...small]<pivot  
# (small...i)=pivot  
# [large...right]>pivot  
while i <= large:  
    if arr[i] < pivot:  
        small += 1  
        arr[i], arr[small] = arr[small], arr[i]  
        i += 1  
    elif arr[i] == pivot:  
        i += 1  
    else:  
        arr[i], arr[large] = arr[large], arr[i]  
        large -= 1  
arr[left], arr[small] = arr[small], arr[left]  
quick_sort(arr, left, small - 1)  
quick_sort(arr, large + 1, right)  
return arr
```

## 前缀和 & 差分

> 2024/09/15 2848题目接触到差分数组，[参考资料](https://oi-wiki.org/basic/prefix-sum/#%E5%89%8D%E7%BC%80%E5%92%8C)

前缀和：数列前n项的和

差分定义：
1. $b_i=a_i-a_i-1,i\gt 2$
2. $b_i=a_1,i=1$

## dfs & bfs

深度优先搜索：使用stack
1. 添加起始点
2. 取stack末尾元素（**一定是先遍历上一个节点的子节点，再遍历相邻节点**）
3. 将其添加到visited，并将其子节点添加到stack中
4. 重复上述过程直到stack空为止

广度优先搜索：使用queue
1. 添加起始点
2. 取queue队头元素（**一定是先遍历相邻节点，再遍历子节点**）
3. ...

值得一提的是：
1. dfs和bfs只能用于连通图，否则会遗漏部分节点
	1. 无向图的连通图
	2. 有向图的强连通图
		1. 有向图的弱连通图也无法访问全部节点
2. 对于弱连通图，如果已知所有的节点，通过如下代码可确保访问到所有节点：
```python
for node in nodes:
	if node not in visited:
		dfs/bfs(node)
```
3. BFS：由于广度优先搜索以层次递增的方式访问节点，当BFS首次访问到目标节点时，路径的长度是最短的（经过的边数最少）
## 拓扑排序

### Kahn算法
> 核心逻辑：维持一个入度为0的顶点的集合

```python
s = [] #存放入度为0的节点
l = [] #存放拓扑排序的结果
inDegree ={} #存放每个节点的入度
# graph使用邻接链表表示，其中key为节点，value为key依赖的items
for node in graph:
	inDegree[node] =len(graph[node])
while len(s):
	node =s[-1]
	l.append(node)
	# 所有依赖于node的入度-1，如果为0，也添加到s中
	for n in graph[node]:
		if (inDegree[n]-1==0):
			s.append(n) 
# 是否包含所有节点，是则说明不存在环
return len(l)==len(graph.keys())
```
### DFS算法

