前言：
百度二跳精排后多样性分流模块入口函数：
`RecallDataDiversitySplitFunction`继承自`StrategyFunction<DiversityListGeneratorStrategy>`

一些前置知识：
1. 派生类：继承已有类创建的类
2. 虚函数：基类中定义的成员函数，有默认实现，允许派生类重写
	1. 纯虚函数：基类中定义的成员函数，无默认实现（virtual关键字 =0标识），强制派生类重写

```c++
using StrategyPlugin = feed::general::neutron::StrategyPlugin;
typedef baidu::feed::mlarch::babylon::ApplicationContext ApplicationContext;
template <class T>
class StrategyFunction : public GRCGraphFunction {
private:
    virtual int32_t init_impl(const comcfg::ConfigGroup* config) noexcept = 0;
    virtual int32_t init(const comcfg::ConfigGroup* config) noexcept override final {
	    // 单例模式 + 依赖注入
        auto _strategy_plugin = ApplicationContext::instance().get<StrategyPlugin>();
        GET_CONF_FIELD_CHECK((*config), phase_name, phase_name, cstr)
        auto& switch_param = _strategy_plugin->switch_param();
        for (auto& pair : switch_param.strategy_confs) {
            auto it = pair.second.phase_confs.find(phase_name);
            const auto& strategy_conf = it->second;
            // 存入depend指针
            for (auto& depend : strategy_conf->depends) {
                strategy_context.add_depend(depend, this->vertex());
            }
        }
        strategy_conf_depend = this->vertex().named_dependency(phase_name + "_conf");
        return init_impl(config);
    }

    virtual int32_t process_impl(const T* strategy_conf) noexcept = 0;
    virtual int32_t process() noexcept override final {
        // 设置vertex_context
        strategy_context.set_vertext_context(context);
        // 获取配置
        auto phase_conf_p = strategy_conf_depend->value<PhaseConf>();
        const T* strategy_conf = dynamic_cast<const T*>(phase_conf_p);
        return process_impl(strategy_conf);
    }
protected:
    std::string phase_name{""};
    GraphDependency* strategy_conf_depend{nullptr};
    StrategyContext strategy_context;
};
```


## 插件机制


## IOC
