> 参考资料：https://oi-wiki.org/lang/

## C++ 基础

c++兼容c，可直接使用c语言中的头文件，不同的是名称发生变化，例如：`stdio.h -> cstdio`

c++的输入，输出：
1. `cstdio`：scanf和printf
2. `iostream`：std::cin和std::cout（std为c++标准库所使用的命名空间）

数据类型：[详细链接](https://zh.cppreference.com/w/cpp/language/type)
基础数据类型：void，空指针，整数类型，字符类型，布尔类型，浮点类型
1. c++11之前，使用`NULL`表示空指针常量，但其实现一般为`#define NULL 0`
	1. 空指针和整数0混用会导致一些问题
2. c++11之后，引入`nullptr`关键字作为空指针常量
高级数据类型：数组，结构体（c++不同于c，此处struct被扩展为类似class的类说明符），联合体，指针

**变量定义时，未初始化的全局变量会被初始化为0，但局部变量不会初始化，需要手动赋值**

指针：
1. 声明指针变量：`<type>* <variable>`
2. 获取变量地址：`&<variable>`
3. 获取指针变量指向空间的值：`*<pointer_variable>`（解引用）

指针偏移：指针变量自增1，其指向的地址偏移量为其类型所占内存大小，以int为例，偏移4个字节

指针的进阶使用：
> 通过指针，程序编写者可以操作程序运行时各处的数据，而不必局限于作用域

1. 指针类型参数的使用
	1. c/c++中，调用函数时传入的参数，均以拷贝的形式传入子过程（函数内部？）中。默认情况下，函数仅能通过返回值将结果返回到调用处。
	2. **函数希望修改外部数据**
	3. **某个结构体数据量较大，不宜进行拷贝**
2. 动态实例化：c++中，可通过new运算符获取一块内存，返回申请内存的地址值
	1. new申请的内存需要通过delete释放

函数：
函数一般是若干语句的集合，可将其称作【子过程】。

函数指针：
函数的参数类型，个数以及返回值类型统一称作接口类型。**有时，若干个函数的接口类型是相同的，使用函数指针可以根据程序动态的选择需要调用的函数。**

如果获取一个函数的地址呢？
1. `fn`：函数本身可以隐式转换为指向函数的指针
2. `&fn`：`&` 运算符可以取得到对象的地址，这对函数也是成立的（但不能说函数是对象）
3. `*fn`：fn本身可以视作函数指针，`*`可获取到fn，又可以视作函数指针....
4. `****fn`：

## C++进阶
类：
结构体（成员元素）的扩展，还可以拥有成员函数。在面向对象编程中，对象就是类的实例，也是变量。

访问说明符：struct成员默认为public，class成员默认为private
1. public
2. protected
3. private
其他概念：
1. 派生类：等同于子类
2. 友元：**一种特殊机制**，允许某一个类或函数访问另一个类的私有成员和保护成员
	1. 常用于：需要对类内部实现进行访问，但又不希望这些成员暴漏

初始化列表：用于对象创建时初始化类成员变量的语法。其在构造函数定义中位于函数主体之前，可直接初始化对象的成员变量
```c++
class Box{
	private:
		int width;
		int height;
		int* test;
	public:
		// 初始化列表
		Box(int w,int h):width(w),height(h){};
		~Box(){
			delete test;
		};
}
```

类中成员元素包含指针，需要手动销毁，此时需要用到析构函数，见上文。

命名空间：解决复杂项目中名字冲突的问题

声明命名空间之后，如果在namespace外部访问其内部成员，需要在成员名前加上`<namespace>::`，使用`using`指令可免去前面的前缀。
1. `using namespace::xxx`：省略某个成员的前缀
2. `using namespace <name>`：省略任何成员的前缀

值类别：
1. 最初：
	1. 左值：能够出现在赋值运算符左侧的值。（右值同理）
2. c和c++11以前
	1. 左右值的判断标准与赋值运算符无关
	2. 左值：能进行取地址运算的值（左值是有内存地址的对象）
	3. 右值：只是一个中间计算结果
3. c++11
4. c++17

重载运算符：
1. 函数调用运算符：只能重载为成员函数
	1. 常见应用：将重载了 `()` 运算符的**结构体**作为自定义比较函数传入优先队列等 STL 容器中。
2. 比较运算符
	1. 在 `std::sort` 和一些 STL 容器中，需要用到 `<` 运算符。在使用自定义类型时，我们需要手动重载。

引用：
> 可看作c++封装的指针，用来传递它所指向的对象。
> 引用：在声明时必须指向对象，对引用的一切操作等同于对原对象的操作。
> **引用不是对象**，因此不存在引用数组（但有指针数组），无法获取引用的指针，也不存在引用的引用。

1. 左值引用：`<type>& <left_ref>`
	1. 应用场景：函数参数传递，对象别名
	2. 一般只能绑定左值（const的左值引用可以绑定到右值）
2. 右值引用：`<type>&& <right_left>`
	1. 应用场景：
		1. 移动语义：
		2. 完美转发

移动语义：它允许程序通过“移动”资源而不是“复制”资源来优化性能。
1. 右值引用：移动语义的基础，其可捕获一个右值并转移它的资源，而不是复制
2. 移动构造函数
3. 移动赋值运算符
4. `std::move`：将一个左值强制转换为右值引用，以便触发移动语义
	1. 原对象（左值）的资源所有权被转移，可能处于有效但未定义的状态

lambda表达式：`[capture] (parameters) mutable -> return-type {statement}`
1. capture：指定哪些变量被捕获，以及捕获是通过值还是引用
2. parameters：可省略
3. mutable：略
4. return-type：可省略
5. statement：

## C++标准库
1. Sequence Containers
	1. vector：仅能从后端添加元素的顺序表
		1. 底层仍然是定长数组，它实现动态扩容是增加了避免数量溢出的操作
		2. 元素的数量（size） / 容量（max_size） 是两个概念
	2. array：**定长**顺序表，c风格数组的简单包装
	3. deque：双端都可添加元素的顺序表
		1. 
	4. list：可**双向遍历**的链表
	5. forward_list：只能**单向遍历**的链表
2. Associative Containers：通常基于**红黑树**实现
	1. set：**有序**的存储**互异**元素的容器，以某种比较元素大小的谓词进行排列。
		1. 有序：由于元素的存储和查找是基于红黑树，故是有序的
		2. 谓词：返回值为真或假的函数。
		3. 互异：也即set中不能有两个相同的元素
	2. multiset：有序存储元素，允许相等的元素。
	3. map：由键值对组成的集合，以某种比较键大小关系的谓词进行排列
	4. multimap
3. Unordered Containers：通过哈希函数进行存储和查找，故是无序的
	1. Unordered set/multiset
	2. Unordered map/multimap
4. 容器适配器：
	1. stack：
	2. queue：
	3. priority_queue：元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列

上述涉及到排序的容器，均可在定义时传入自定义的比较函数（也即谓词）
```c++
priority_queue<TypeName,Container,Compare> q;

```

迭代器：
在 STL 中，迭代器（Iterator）用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似，但是它封装了一些有效性检查，并且提供了统一的访问格式。
```c++
vector<int> data(10); 
for (int i = 0; i < data.size(); i++) 
	cout << data[i] << endl; // 使用下标访问元素 
for (vector<int>::iterator iter = data.begin(); iter != data.end(); iter++) 
	cout << *iter << endl; // 使用迭代器访问元素 
// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码
```
