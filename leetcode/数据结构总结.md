## 前缀和
> 数列的前n项的和，一种重要的预处理方式，可大大降低查询的时间复杂度

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 _该数组中和为 `k` 的子数组的个数_ 。
子数组是数组中元素的连续非空序列。

`pre[i]`：表示以i为开头，到末尾的后缀和。则以i为开头，j结尾的子序列和为：`pre[i]-pre[j+1]`，故只需要统计`pre[i]-pre[j+1]=k`即可，也即`pre[i]=pre[j+1]+k`（j一定大于i）
故我们可以倒序遍历`nums`计算`pre[i]`，并将`pre[j+1]+k`作为key存到hashmap中，由于j大于i，故遍历到`pre[i]`时，所有`pre[j+1]+k`已经全部记录到hashmap中，故直接获取其值即可

## 二叉树

前序遍历：根节点 左子树 右子树
中序遍历：左子树 根节点 右子树
后序遍历：左子树 右子树 根节点
leetcode105：根据前序与中序遍历序列构造二叉树

层序遍历：基于队列实现
1. 进阶操作：如果需要对每一层进行特殊操作，可以在每次`pop(0)`前记录当前队列的长度，通过`while length`完成该层的特殊操作
	1. 相关题目：leetcode 102，101

## 单调栈

1.  [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)


## 字符串

字符串中的一些概念需要区分一下：
1. 子序列：在原字符串中不连续，但先后顺序保持一致
2. 子串：在原字符串中连续

**最长公共子序列（论文查重原理）**
1. 给定字符串s和t，从后向前看子序列匹配
2. 定义`dfs(i,j)`：表示s前i个字母和t的前j个字母的最长公共子序列长度
	1. `s[i]==t[j]`：`dfs(i,j)=max(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1)+1)`
		1. 优化：无需前两项，假设`dfs(i,j-1)>dfs(i-1,j-1)+1`，则`s[i]`一定包含在LCS中
			1. 如果`s[i]`不包含在LCS中，则`dfs(i,j-1)=dfs(i-1,j-1)`，矛盾，故得证
			2. 基于上述结论，则`dfs(i,j-1)=dfs(i-1,j-1)+1`，矛盾，故前两项大于等于第三项，可忽略
	2. `s[i]!=t[j]`：`dfs(i,j)=max(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1))`
		1. 优化：无需`dfs(i-1,j-1)`，因为前两项的值一定大于等于第三项
3. 综上：
	1. `s[i]==t[j]`：`dfs(i,j)=dfs(i-1,j-1)+1`
	2. `s[i]!=t[j]`：`dfs(i,j)=max(dfs(i-1,j),dfs(i,j-1))`

**编辑距离**
1. 类比于LCS
2. `s[i]==t[j]`：`dfs(i,j)=dfs(i-1,j-1)`，不用多说
3. `s[i]!=t[j]`：`dfs(i,j)=min(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1))+1`
	1. 遇到不同的字符时，有插入，删除，替换三种方式
		1. 插入：`dfs(i,j-1)`，s插入一个与`t[j]`相同的字符，后续比较时s相当于没变，t只看前`j-1`个字符
		2. 删除：`dfs(i-1,j)`，此时t不变，s只看`i-1`个
		3. 替换：很容易理解了...