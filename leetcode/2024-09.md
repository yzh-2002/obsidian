## 0908

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

思路：正常排序的时间复杂度最低为`O(nlog(n))`

c++的sort算法是一种混合排序方法，结合了快速排序，堆排序和插入排序的特点
1. 快速排序：时间复杂度为`O(nlog(n))`，由于递归，会产生`O(log(n))`的栈空间
2. 堆排序：快速排序特定情况下可能出现`O(n^2)`的时间复杂度，此时切换为堆排序
3. 插入排序：对小数组的排序效率更高

若要实现`O(n)`的时间复杂度，则不能使用上述排序算法。

解法：
1. 找到非负与负数之间的下标分界pivot
2. 平方后`nums[0]-nums[pivot]`递减，`nums[pivot+1]-nums[nums.size()-1]`递增
3. 归并排序，双指针即可实现`O(n)`复杂度

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

思路：嵌套循环`O(mn)`

解法：
1. 获取两链表的长度m和n
2. 让较长的链表头指针先走m-n步
3. 同时走，通过是否相等来判断相交节点

## 0909

### [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/)

没有什么特别的算法，主要是对链表这一数据结构的熟悉程度

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

思路：找到从二叉树根节点到目标节点的访问序列，然后比对两个序列即可获取最近公共祖先

问题：题中的二叉树不是二叉搜索树，访问序列不易得到？？？

解法：二叉树等天然递归形成的数据结构，有时一定要从递归的角度思考思考

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	// 递归出口
	if (root==NULL || root==p || root==q){
		return root;
	}
	TreeNode *left =lowestCommonAncestor(root->left,p,q);
	TreeNode *right =lowestCommonAncestor(root->right,p,q);
	// 左子树不存在p和q，那就一定都在右子树
	if (left==null) return right;
	// 同上
	if (right==null) return left;
	// 如果左右子树均有节点，那么最近祖先就是当前的root节点
	return root;
}
```

## 0910

### [2552. 统计上升四元组](https://leetcode.cn/problems/count-increasing-quadruplets/)

没有思路

题解：
1. 难点一：对于涉及多个元素排列的问题，可以将其拆分为**枚举+维护**来做。对该题而言，不能暴力四层遍历解决，可以仅对中间的`j,k`进行枚举，同时维护`i,l`与他们的关系即可
2. 难点二：如何维护
	1. 构造一个`greater[k][x]`：在k之后，有多少个元素大于x
	2. 构造一个`less[j][x]`：在j之前，有多少个元素小于x
	3. 最终结果：`greater[k][nums[j]]*less[j][nums[k]]`中所有k，j对的和
3. 难点三：`greater[k][x]`如何统计？
	1. 暴力思路：给定k，x，遍历k+1到n-1，并比较元素与x的大小，时间复杂度O(n^3)
	2. 巧妙思路：倒着遍历k，也即从n-2到1
		1. 初始化`greater[-1]=0*(n+1)`
		2. 对于k=n-2，其后面仅存在一个元素`nums[k+1]`，此时`greater[k]`只需要把从`0-nums[k+1]-1`的元素自增一即可
		3. 对于后续的k，只需要在`greater[k-1]`的基础上根据`nums[k+1]`的大小来确定哪些下标自增1即可，时间复杂度`O(n^2)`
上述是题解中的三个难点，下面是在此基础上的一些优化手段：
1. 一些循环可以合并处理，优化掉less数组的第一个纬度
2. less数组本身也可省略掉，因为nums本身是1-n的排列，所以有了`greater`数组之后，可以通过`greater[j][x]`得到j右边比x大的元素，则j右边比x小的元素有`n-1-j-greater[j][x]`，那么j左边比x小的元素个数有`less[j][x]=x-(n-1-j-greater[j][x])`，挺难想到的...

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

思路：回文，栈存储元素，遇到不同的就入栈，相同出栈，最后看栈中是否有元素，但题目要求O(1)空间复杂度。

解法：
1. 寻找链表的中间节点，此处可使用**快慢指针**一次遍历得到，快指针到尾部时，慢指针到中间
2. 反转满指针后面的链表
3. 依次遍历两部分的元素，判断是否回文即可

## 0911

### [2555. 两个线段获得的最多奖品](https://leetcode.cn/problems/maximize-win-from-two-segments/)

思路：
1. hashmap存储每个数字出现个数
2. 双层遍历hashmap的keys，统计每次`i-i+k`以及`j-j+k`的个数（还需要一层循环）
3. 时间复杂度：0(kn^2)，空间复杂度：O(n)

上述思路理解存在一个误解：
1. 即认为所选线段的端点必须在给定的数组元素中，实则无所谓，最终上述代码在case 3超时...
2. 忽略了数组的有序性，也即线段i-j中奖品的个数，只需要获取i对应数组下标ii（j同理），然后奖品个数可由`ij-ii`得到

解法：思想和昨天统计上升四元组类似，也即我们不需要双层遍历，而是遍历其中一个，其他的变量去**维护相应关系**即可

1. 设第二条线段右端点为`p[i]`，则其左端点为`p[i]-k`
	1. 需要注意的是，该端点不一定在数组p中，故需要找出离其最近的值`p[j]`（二分查找），这样`j-i`即为第二条线段的奖品个数
	2. 此时需要知道位于`p[j]`左侧第一条线段可覆盖最大数量即可
2. `p[j]`左侧第一条线段可覆盖最大数量**可以作为一个子问题单独求解，并将结果用hashmap存储**，类似于昨天的统计上升四元组
	1. 遍历时需要从左向右遍历，这样可以一次遍历获取结果
3. 最后遍历第二条线段右端点即可，需要考虑一些边界条件，此处不再赘述

进阶解法：
1. 动态规划
2. 滑动窗口

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

之前做过留有印象，使用单调栈做了出来