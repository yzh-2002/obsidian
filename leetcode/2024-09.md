## 0908

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

思路：正常排序的时间复杂度最低为`O(nlog(n))`

c++的sort算法是一种混合排序方法，结合了快速排序，堆排序和插入排序的特点
1. 快速排序：时间复杂度为`O(nlog(n))`，由于递归，会产生`O(log(n))`的栈空间
2. 堆排序：快速排序特定情况下可能出现`O(n^2)`的时间复杂度，此时切换为堆排序
3. 插入排序：对小数组的排序效率更高

若要实现`O(n)`的时间复杂度，则不能使用上述排序算法。

解法：
1. 找到非负与负数之间的下标分界pivot
2. 平方后`nums[0]-nums[pivot]`递减，`nums[pivot+1]-nums[nums.size()-1]`递增
3. 归并排序，双指针即可实现`O(n)`复杂度

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

思路：嵌套循环`O(mn)`

解法：
1. 获取两链表的长度m和n
2. 让较长的链表头指针先走m-n步
3. 同时走，通过是否相等来判断相交节点

## 0909

### [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/)

没有什么特别的算法，主要是对链表这一数据结构的熟悉程度

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

思路：找到从二叉树根节点到目标节点的访问序列，然后比对两个序列即可获取最近公共祖先

问题：题中的二叉树不是二叉搜索树，访问序列不易得到？？？

解法：二叉树等天然递归形成的数据结构，有时一定要从递归的角度思考思考

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	// 递归出口
	if (root==NULL || root==p || root==q){
		return root;
	}
	TreeNode *left =lowestCommonAncestor(root->left,p,q);
	TreeNode *right =lowestCommonAncestor(root->right,p,q);
	// 左子树不存在p和q，那就一定都在右子树
	if (left==null) return right;
	// 同上
	if (right==null) return left;
	// 如果左右子树均有节点，那么最近祖先就是当前的root节点
	return root;
}
```

## 0910

### [2552. 统计上升四元组](https://leetcode.cn/problems/count-increasing-quadruplets/)

没有思路

题解：
1. 难点一：对于涉及多个元素排列的问题，可以将其拆分为**枚举+维护**来做。对该题而言，不能暴力四层遍历解决，可以仅对中间的`j,k`进行枚举，同时维护`i,l`与他们的关系即可
2. 难点二：如何维护
	1. 构造一个`greater[k][x]`：在k之后，有多少个元素大于x
	2. 构造一个`less[j][x]`：在j之前，有多少个元素小于x
	3. 最终结果：`greater[k][nums[j]]*less[j][nums[k]]`中所有k，j对的和
3. 难点三：`greater[k][x]`如何统计？
	1. 暴力思路：给定k，x，遍历k+1到n-1，并比较元素与x的大小，时间复杂度O(n^3)
	2. 巧妙思路：倒着遍历k，也即从n-2到1
		1. 初始化`greater[-1]=0*(n+1)`
		2. 对于k=n-2，其后面仅存在一个元素`nums[k+1]`，此时`greater[k]`只需要把从`0-nums[k+1]-1`的元素自增一即可
		3. 对于后续的k，只需要在`greater[k-1]`的基础上根据`nums[k+1]`的大小来确定哪些下标自增1即可，时间复杂度`O(n^2)`
上述是题解中的三个难点，下面是在此基础上的一些优化手段：
1. 一些循环可以合并处理，优化掉less数组的第一个纬度
2. less数组本身也可省略掉，因为nums本身是1-n的排列，所以有了`greater`数组之后，可以通过`greater[j][x]`得到j右边比x大的元素，则j右边比x小的元素有`n-1-j-greater[j][x]`，那么j左边比x小的元素个数有`less[j][x]=x-(n-1-j-greater[j][x])`，挺难想到的...

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

思路：回文，栈存储元素，遇到不同的就入栈，相同出栈，最后看栈中是否有元素，但题目要求O(1)空间复杂度。

解法：
1. 寻找链表的中间节点，此处可使用**快慢指针**一次遍历得到，快指针到尾部时，慢指针到中间
2. 反转满指针后面的链表
3. 依次遍历两部分的元素，判断是否回文即可

## 0911

### [2555. 两个线段获得的最多奖品](https://leetcode.cn/problems/maximize-win-from-two-segments/)

思路：
1. hashmap存储每个数字出现个数
2. 双层遍历hashmap的keys，统计每次`i-i+k`以及`j-j+k`的个数（还需要一层循环）
3. 时间复杂度：0(kn^2)，空间复杂度：O(n)

上述思路理解存在一个误解：
1. 即认为所选线段的端点必须在给定的数组元素中，实则无所谓，最终上述代码在case 3超时...
2. 忽略了数组的有序性，也即线段i-j中奖品的个数，只需要获取i对应数组下标ii（j同理），然后奖品个数可由`ij-ii`得到

解法：思想和昨天统计上升四元组类似，也即我们不需要双层遍历，而是遍历其中一个，其他的变量去**维护相应关系**即可

1. 设第二条线段右端点为`p[i]`，则其左端点为`p[i]-k`
	1. 需要注意的是，该端点不一定在数组p中，故需要找出离其最近的值`p[j]`（二分查找），这样`j-i`即为第二条线段的奖品个数
	2. 此时需要知道位于`p[j]`左侧第一条线段可覆盖最大数量即可
2. `p[j]`左侧第一条线段可覆盖最大数量**可以作为一个子问题单独求解，并将结果用hashmap存储**，类似于昨天的统计上升四元组
	1. 遍历时需要从左向右遍历，这样可以一次遍历获取结果
3. 最后遍历第二条线段右端点即可，需要考虑一些边界条件，此处不再赘述

进阶解法：
1. 动态规划
2. 滑动窗口

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

之前做过留有印象，使用单调栈做了出来

## 0912

### [2576. 求出最多标记下标](https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/)

思路：
1. 从小到大排序，`O(nlogn)`
2. 遍历：~~从后到前排序，也即应优先寻找满足条件的较大数字（小数字可能存在多个配对项，但大数字一般只有一个配对项）~~
	1. 上述逻辑实操有问题
3. ~~此处可以双指针，一个指针指向开头，另一个指针指向数组中间下标，开始遍历....~~
	1. ~~需要额外一个数组，存储已经配对的下标~~
	2. 

~~问题：这种遍历方式是一种直觉，没有理论推导，为什么这样遍历可以不遗漏所有情况呢？？~~

上述逻辑其实也没问题，关键在于双指针遍历时，如果不满足条件应该怎么办？
1. 此时需要固定左指针，增大右指针去寻找可能满足的配对
2. 画图理解一下...

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

递归很简单，不再说了

## 0913

### [2398. 预算内的最多机器人数目](https://leetcode.cn/problems/maximum-number-of-robots-within-budget/)

题干很奇怪，不明白为什么要乘以k

机器人需要连续，考虑使用滑动窗口求解，但是自己写的超时了，关键在于每次移动时，窗口最大值的维护？？

题解：
1. 使用单调队列：可以快速查询特定范围（滑动窗口）内的最小值和最大值
2. 说明：以维护滑动窗口内最大值为例，使用单调递减滑动窗口
3. 窗口右移时，在新元素入队之前，先将比其小的元素全部pop出去，此时窗口最大元素始终保持在队头
4. 窗口左移时，如果排除的元素包含在队列中，则出队，仍可保持队头为剩余窗口元素最大值

### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

动态规划，但想不到子问题如何设置？

题解：
1. `dp[i,j]`表示以i，j作为右下角，所能构成正方形的最大边长
	1. 自己也曾设想过，但将其值认为是0/1，也即是否为正方形，导致后续没有思路了.....
	2. 其实此处设想为最大边长也很自然，毕竟是求面积，还是要多练
2. 状态转移方程：`dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1`
3. ...

## 0914

### [2390. 从字符串中移除星号](https://leetcode.cn/problems/removing-stars-from-a-string/)

一分钟秒了，很简单

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

题目要求时间复杂度为O(n)，没啥思路

题解：
1. 优先队列：维护一个大小为K的优先队列，时间复杂度$O(nlog(k))$
	1. 先把前k个元素添加到最小堆中，此时堆顶为当前第k大元素
	2. 之后的每个元素与堆顶元素比较：
		1. 如果比其小，不做任何处理
		2. 如果比其大，则将堆顶弹出，该元素加入，堆经过调整后还是第k大元素
2. 基于快速排序的算法：
	1. 快速排序每次分治之后，pivot元素在最终排序的下标便确定了，只需要在快速排序内部添加一个判断，某次pivot元素下标为n-k即可
	2. 必须使用三路快排优化，不然时间过不了...
	3. 时间复杂度如何分析？？
		1. ....

## 0915
### [2848. 与车相交的点](https://leetcode.cn/problems/points-that-intersect-with-cars/)

思路：
1. 先排序，确保每一个二元组按照第一个元素从小到大的顺序
2. 遍历数组，每次只需要记录上一个元素的开头和所有交集的结束位置
	1. 判断新元素与其是否存在交集即可
3. 时间复杂度`O(nlog(n))`，空间复杂度`O(n)`

题解：差分数组
1. 不使用差分数组，维护一个数组C，其大小为给定nums中end最大值
2. 遍历数组中每一个元素，再遍历其子数组的每一个元素，为对应数组C下标+1
3. 统计数组C中值大于1的元素个数即可，时间复杂度O(nC)，空间复杂度O(C)

1. 考虑到数组C自增的操作是在**一连续区间内**进行的，故可以定义差分数组：
	1. $diff[i]=count[i],i=0$
	2. $diff[i]=count[i]-count[i-1],i\gt0$
	3. 这样`count[i]`的值可从`diff[0]->diff[i]`累加得到
2. 我们需要对count数组从x到y自增一，只需要对diff数组，`diff[x]`增加1，`diff[y+1]`减少一，然后对diff求一边前缀和即可

**说实话，并不太理解这种做法，下次还是想不到....**

### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

题解：
1. **每一个节点都是一个大小为26的数组，并带有`isEnd`表示单词是否结束**
2. 对每一个单词，将其拆分为一个个字符进行存储
3. ...

## 0916

### [1184. 公交站间的距离](https://leetcode.cn/problems/distance-between-bus-stops/)

给定起点和终点，环形路线只有两条路，顺时针走或逆时针走
故一次遍历获取总路程t，在求出起点-终点的顺时针路程s，比较s和t-s即可

### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

思路：hash表存储每个课程的前置课程，遍历元素时对于每个课程C，先判断其前置课程中是否包含C（此处使用stack获取其所有前置课程（前置课程的前置课程...）），包含则直接返回False，时间复杂度：O(n^3)（最坏情况，不确定计算是否正确...）

题解：拓扑排序问题
1. kahn算法
2. dfs算法，不是很懂....


## 0917

### [815. 公交路线](https://leetcode.cn/problems/bus-routes/)

没什么思路，但看了相关提示：bfs
**一开始就应该想到这是一个图结构的.....**

但还是没思路，图结构可以很方便解决是否可达的问题，但怎么解决公交车数量最少呢？

1. 初始：将起始车站入队
2. 遍历经过起始车站的公交车（此处需要一个`hashmap[i]`表示第i站经停的公交车），将这些公交车能到达的车站入队（**已经入过队的车站**无需再入，visited数组）
3. 遍历队列中的公交车，将这些公交车能到达的车站入队
	1. **已经访问过的公交车**无需再遍历
	2. 已经入队的车站无需再入
4. 直到没有车站入队，bfs结束

**为什么这样就是公交车数量最少的呢？**

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

链表基本功，不再赘述...

## 0918
### [2332. 坐上公交的最晚时间](https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/)

思路：
1. 将bus到站时间和passenger到站时间从小到大排序
2. 对每辆bus，假定我乘坐该辆车的最晚时间
	1. 如果该辆车坐满，最晚时间为最后一个能乘车乘客的到站时间-1
	2. 如果该辆车坐不满，最晚时间为其到站时间或到站时间-1
3. 问题：需要考虑上述假设的乘车时间与passengers到站时间冲突的情况
	1. 只需不断减1即可

时间复杂度是$O(n^2log(n))$，击败了9%，空间复杂度是O(n)，击败了97%的人。

解法：遍历思路不同，
1. 遍历寻找所有乘客中最后一个能上车的乘客，然后将他挤下去
2. 或者，公交车有空余的，那么就赶最后一辆车发车时到站即可


### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

没想出来....

题解：
1. 岛屿问题，可以将每个节点看作四叉树的根节点，进行dfs遍历
2. 对二维数组中的每一个点进行遍历
	1. 如果该点为0，跳过
	2. 该点为1，且未被遍历过，则dfs遍历，同时岛屿数量加一
		1. 遍历过程中标记所有遍历为1的点
		2. 越界或者遇到为0的点则停止遍历

dfs可以确保将一个岛屿中所有的点全部标记。

## 0919

### [2414. 最长的字母序连续子字符串的长度](https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/)

滑动窗口秒了...

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

没啥思路，看提示说要动态规划解决该问题

拆分子问题（关键在于分类讨论），挺明显的，秒解

## 0920

### [2376. 统计特殊整数](https://leetcode.cn/problems/count-special-integers/)

通用解法：数位dp

小技巧：
整数的集合可以转换成二进制数的形式，二进制从低到高第i位为1表示i在集合中，例如：`{0,2,3}`对应二进制数为`1101`
1. 判断元素d是否在集合中：`x >> d &1`
2. 将元素d添加到集合中：`x = x|(1<<d)`

```python
@cache
def f(i:int,mask:int,is_limit:bool,is_num:bool)->int:
	'''
	@params i: 开始填充数字的位数
	@params mask: i前面填充的数字的集合
	@params is_limit：表示前面填的数字是否都是n对应位上的，是则当前位最多为n[i]，否则为9
	@params is_num：表示前面是否填充了数字，是则当前位可从0开始，否则可以跳过，或从1开始填数字
	@return: 返回从i开始填数字，能构造出来的特殊整数的数目
	'''
	if i==len(s): #结束，如果先前构造过数字，则为1，否则为0
		return int(is_num)
	res =0
	if not is_num: # 前面均跳过，情况1：当前位也跳过
		res =f(i+1,mask,False,False)
	up = int(s[i]) if is_limit else 9 #当前可填数字的上届
	down = 0 if is_num else 1 # 下届
	# 情况2：当前位从1开始填数字
	for d in range(down,up+1):
		if mask>>d &1==0: #mask里没有d，也即无重复
			# 下一位是否首先仅取决于一种情况：上一位受限制，且当前位取到up
			res+=f(i+1,mask|(1<<d),is_limit and d==up,True)
	return res	
```

### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

题目要求时间复杂度O(n)，空间复杂度O(1)
一开始想到了题解中`异类相消`的思路，只不过我的想法是用栈维护，遇到同类就入栈，不同类就出栈，最后栈中保留的元素就是多数元素

其实无需栈也可以实现

## 0921

### [2374. 边积分最高的节点](https://leetcode.cn/problems/node-with-highest-edge-score/)

hashmap，一次遍历即可，时间空间复杂度均为O(n)

### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

看到前缀和之后利用两个数组，一个存储前缀乘积，一个存储后缀乘积，最后由两个数组可得到结果，时间，空间复杂度均为O(n)

思路是对的，前缀乘积和后缀乘积的数组可以消去一个，其中一个可以边计算边更新

## 0922

### [997. 找到小镇的法官](https://leetcode.cn/problems/find-the-town-judge/)

统计出入度即可

### [155. 最小栈](https://leetcode.cn/problems/min-stack/)

思路：额外创建一个最小堆维护最小值即可

题解：辅助栈
1. 每个元素入栈时，比较其与先前栈中最小值的大小，更小，则将该元素同时插入辅助栈中，否则辅助栈中继续插入原先的最小值
2. 出栈时，辅助栈同步出栈
3. 每次想要获取栈中最小值，只需要获取辅助栈的末尾元素即可

上述算法的思想就是利用栈的性质

## 0923

### [1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/)

关键在于：不能把`nums[i]`和i看作两个无关变量，而是将其视作一个变量去处理

### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

一开始想用滑动窗口来做，但是滑动窗口的状态无法维护，行不通

看了题解，动态规划，没想到怎么保证连续

1. 定义`dp[0][i]`表示以第i结尾的乘积最大值，`dp[1][i]`表示以i结尾的乘积最小值
	1. **注意此处dp的定义，是以i结尾，而不是前i个元素中连续子序列的乘积最大值，这样就解决了连续的问题**
	2. 最后返回结果为`max(dp[0])`
2. 如何更新？
	1. `dp[0][i]=max(dp[0][i-1]*nums[i],dp[1][i-1]*nums[i],nums[i])`
	2. 同理

dp难就难在怎么拆分子问题，以及状态更新上.....