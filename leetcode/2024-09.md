## 0908

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

思路：正常排序的时间复杂度最低为`O(nlog(n))`

c++的sort算法是一种混合排序方法，结合了快速排序，堆排序和插入排序的特点
1. 快速排序：时间复杂度为`O(nlog(n))`，由于递归，会产生`O(log(n))`的栈空间
2. 堆排序：快速排序特定情况下可能出现`O(n^2)`的时间复杂度，此时切换为堆排序
3. 插入排序：对小数组的排序效率更高

若要实现`O(n)`的时间复杂度，则不能使用上述排序算法。

解法：
1. 找到非负与负数之间的下标分界pivot
2. 平方后`nums[0]-nums[pivot]`递减，`nums[pivot+1]-nums[nums.size()-1]`递增
3. 归并排序，双指针即可实现`O(n)`复杂度

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

思路：嵌套循环`O(mn)`

解法：
1. 获取两链表的长度m和n
2. 让较长的链表头指针先走m-n步
3. 同时走，通过是否相等来判断相交节点

## 0909

### [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/)

没有什么特别的算法，主要是对链表这一数据结构的熟悉程度

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

思路：找到从二叉树根节点到目标节点的访问序列，然后比对两个序列即可获取最近公共祖先

问题：题中的二叉树不是二叉搜索树，访问序列不易得到？？？

解法：二叉树等天然递归形成的数据结构，有时一定要从递归的角度思考思考

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	// 递归出口
	if (root==NULL || root==p || root==q){
		return root;
	}
	TreeNode *left =lowestCommonAncestor(root->left,p,q);
	TreeNode *right =lowestCommonAncestor(root->right,p,q);
	// 左子树不存在p和q，那就一定都在右子树
	if (left==null) return right;
	// 同上
	if (right==null) return left;
	// 如果左右子树均有节点，那么最近祖先就是当前的root节点
	return root;
}
```

## 0910

### [2552. 统计上升四元组](https://leetcode.cn/problems/count-increasing-quadruplets/)

没有思路

题解：
1. 难点一：对于涉及多个元素排列的问题，可以将其拆分为**枚举+维护**来做。对该题而言，不能暴力四层遍历解决，可以仅对中间的`j,k`进行枚举，同时维护`i,l`与他们的关系即可
2. 难点二：如何维护
	1. 构造一个`greater[k][x]`：在k之后，有多少个元素大于x
	2. 构造一个`less[j][x]`：在j之前，有多少个元素小于x
	3. 最终结果：`greater[k][nums[j]]*less[j][nums[k]]`中所有k，j对的和
3. 难点三：`greater[k][x]`如何统计？
	1. 暴力思路：给定k，x，遍历k+1到n-1，并比较元素与x的大小，时间复杂度O(n^3)
	2. 巧妙思路：倒着遍历k，也即从n-2到1
		1. 初始化`greater[-1]=0*(n+1)`
		2. 对于k=n-2，其后面仅存在一个元素`nums[k+1]`，此时`greater[k]`只需要把从`0-nums[k+1]-1`的元素自增一即可
		3. 对于后续的k，只需要在`greater[k-1]`的基础上根据`nums[k+1]`的大小来确定哪些下标自增1即可，时间复杂度`O(n^2)`
上述是题解中的三个难点，下面是在此基础上的一些优化手段：
1. 一些循环可以合并处理，优化掉less数组的第一个纬度
2. less数组本身也可省略掉，因为nums本身是1-n的排列，所以有了`greater`数组之后，可以通过`greater[j][x]`得到j右边比x大的元素，则j右边比x小的元素有`n-1-j-greater[j][x]`，那么j左边比x小的元素个数有`less[j][x]=x-(n-1-j-greater[j][x])`，挺难想到的...

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

思路：回文，栈存储元素，遇到不同的就入栈，相同出栈，最后看栈中是否有元素，但题目要求O(1)空间复杂度。

解法：
1. 寻找链表的中间节点，此处可使用**快慢指针**一次遍历得到，快指针到尾部时，慢指针到中间
2. 反转满指针后面的链表
3. 依次遍历两部分的元素，判断是否回文即可

## 0911

### [2555. 两个线段获得的最多奖品](https://leetcode.cn/problems/maximize-win-from-two-segments/)

思路：
1. hashmap存储每个数字出现个数
2. 双层遍历hashmap的keys，统计每次`i-i+k`以及`j-j+k`的个数（还需要一层循环）
3. 时间复杂度：0(kn^2)，空间复杂度：O(n)

上述思路理解存在一个误解：
1. 即认为所选线段的端点必须在给定的数组元素中，实则无所谓，最终上述代码在case 3超时...
2. 忽略了数组的有序性，也即线段i-j中奖品的个数，只需要获取i对应数组下标ii（j同理），然后奖品个数可由`ij-ii`得到

解法：思想和昨天统计上升四元组类似，也即我们不需要双层遍历，而是遍历其中一个，其他的变量去**维护相应关系**即可

1. 设第二条线段右端点为`p[i]`，则其左端点为`p[i]-k`
	1. 需要注意的是，该端点不一定在数组p中，故需要找出离其最近的值`p[j]`（二分查找），这样`j-i`即为第二条线段的奖品个数
	2. 此时需要知道位于`p[j]`左侧第一条线段可覆盖最大数量即可
2. `p[j]`左侧第一条线段可覆盖最大数量**可以作为一个子问题单独求解，并将结果用hashmap存储**，类似于昨天的统计上升四元组
	1. 遍历时需要从左向右遍历，这样可以一次遍历获取结果
3. 最后遍历第二条线段右端点即可，需要考虑一些边界条件，此处不再赘述

进阶解法：
1. 动态规划
2. 滑动窗口

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

之前做过留有印象，使用单调栈做了出来

## 0912

### [2576. 求出最多标记下标](https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/)

思路：
1. 从小到大排序，`O(nlogn)`
2. 遍历：~~从后到前排序，也即应优先寻找满足条件的较大数字（小数字可能存在多个配对项，但大数字一般只有一个配对项）~~
	1. 上述逻辑实操有问题
3. ~~此处可以双指针，一个指针指向开头，另一个指针指向数组中间下标，开始遍历....~~
	1. ~~需要额外一个数组，存储已经配对的下标~~
	2. 

~~问题：这种遍历方式是一种直觉，没有理论推导，为什么这样遍历可以不遗漏所有情况呢？？~~

上述逻辑其实也没问题，关键在于双指针遍历时，如果不满足条件应该怎么办？
1. 此时需要固定左指针，增大右指针去寻找可能满足的配对
2. 画图理解一下...

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

递归很简单，不再说了

## 0913

### [2398. 预算内的最多机器人数目](https://leetcode.cn/problems/maximum-number-of-robots-within-budget/)

题干很奇怪，不明白为什么要乘以k

机器人需要连续，考虑使用滑动窗口求解，但是自己写的超时了，关键在于每次移动时，窗口最大值的维护？？

题解：
1. 使用单调队列：可以快速查询特定范围（滑动窗口）内的最小值和最大值
2. 说明：以维护滑动窗口内最大值为例，使用单调递减滑动窗口
3. 窗口右移时，在新元素入队之前，先将比其小的元素全部pop出去，此时窗口最大元素始终保持在队头
4. 窗口左移时，如果排除的元素包含在队列中，则出队，仍可保持队头为剩余窗口元素最大值

### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

动态规划，但想不到子问题如何设置？

题解：
1. `dp[i,j]`表示以i，j作为右下角，所能构成正方形的最大边长
	1. 自己也曾设想过，但将其值认为是0/1，也即是否为正方形，导致后续没有思路了.....
	2. 其实此处设想为最大边长也很自然，毕竟是求面积，还是要多练
2. 状态转移方程：`dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1`
3. ...

## 0914

### [2390. 从字符串中移除星号](https://leetcode.cn/problems/removing-stars-from-a-string/)

一分钟秒了，很简单

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

题目要求时间复杂度为O(n)，没啥思路

题解：
1. 优先队列：维护一个大小为K的优先队列，时间复杂度$O(nlog(k))$
	1. 先把前k个元素添加到最小堆中，此时堆顶为当前第k大元素
	2. 之后的每个元素与堆顶元素比较：
		1. 如果比其小，不做任何处理
		2. 如果比其大，则将堆顶弹出，该元素加入，堆经过调整后还是第k大元素
2. 基于快速排序的算法：
	1. 快速排序每次分治之后，pivot元素在最终排序的下标便确定了，只需要在快速排序内部添加一个判断，某次pivot元素下标为n-k即可
	2. 必须使用三路快排优化，不然时间过不了...
	3. 时间复杂度如何分析？？
		1. ....



